---
title: "Графика в R-studio"
output: html_notebook
---

# 1. Использование функции plot() для построения графиков

```{r}
# график значений вектора х, упорядоченных вдоль оси х
#plot(x)

# график зависимости y от х
#plot(x, y)
```

```{r}
#В качестве примера используем данные по скорости выведения индометацина из организма человека Индометацин представляет собой один из наиболее активных противовоспалительных препаратов. В эксперименте приняли участие шесть испытуемых. Результаты этого исследования входят в базовый набор данных R и доступны по команде

data(Indometh)

#В состав таблицы Indometh входят переменные Subject (испытуемый), time (время с момента введения препарата) и conc (концентрация препарата в крови). 

names(Indometh)
```

```{r}
#Благодаря команде attach(), теперь мы можем напрямую обращаться к переменным таблицы Indometh (т.е. использовать их имена непосредственно, например, time вместо Indometh$time.

attach(Indometh)
```

```{r}
#Зависимость концентрации индометацина в крови от времени можно легко изобразить при помощи следующей команды:

plot(time, conc)
```

```{r}
#Предположим, что перед нами стоит задача отобразить на графике не все исходные
#данные, а только средние значения концентрации индометацина для каждой временной
#точки. Рассчитать средние значения (или любые другие количественные величины) для отдельных групп данных позволяет функция tapply():

Mean1 <- tapply(conc, time, mean)
Mean1
```

```{r}
#Обратите внимание на то, что при создании вектора means функция tapply() автоматически присвоила каждому из рассчитанных средних величин имя, соответствующее времени учета концентрации индометацина. Это легко проверить:

names(Mean1)
```

```{r}
#Мы можем воспользоваться этим обстоятельством при построении графика следующим образом:

# создаем числовой вектор со значениями времени учета концентрации препарата:

indo.times <- as.numeric(names(Mean1))

# строим график:
plot(indo.times, Mean1)
```

```{r}
#Функция plot() имеет большое количество управляющих параметров, которые позволяют осуществлять очень тонкую настройку внешнего вида графика. Ниже рассмотрены лишь некоторые из них.
```

### 1. Параметры xlab и ylab
```{r}
#Параметры xlab и ylab служат для изменения названий осей X и Y соответственно:

plot(indo.times, Mean1, xlab = "Время", ylab = "Концентрация")
```
### 2. Параметр type

```{r}
#Параметр type позволяет изменять внешний вид точек на графике. Он принимает одно из следующих текстовых значений:
#    • "p" - точки (points; используется по умолчанию)
#    • "l" - линии (lines)
#    • "b" - изображаются и точки, и линии (both points and lines)
#    • "o" - точки изображаются поверх линий (points over lines)
#    • "h" - гистограмма (histogram)
#    • "s" - ступенчатая кривая (steps)
#    • "n" - данные не отображаются (no points)
```

```{r}
plot(indo.times, Mean1, xlab = "Время", ylab = "Концентрация", type = "o")
```
### 3. Параметры xlim и ylim
```{r}
#Эти два параметра контролирут размах значений на каждой из осей графика. По умолчанию они оба принимают значение NULL - в этом случае размах выбирается программой автоматически. Для отмены автоматических настроек соответствующему параметру необходимо присвоить значение в виде числового вектора, содержащего минимальное и максимальное значения, которые должны отображаться на оси. Например:
```

```{r}
plot(indo.times, Mean1, xlab="Время", ylab="Концентрация", xlim=c(0, 15))
plot(indo.times, Mean1, xlab="Время", ylab="Концентрация", ylim=c(0, 5))
```

### 4. Параметры axes и ann

```{r}
#Эти два параметра контролируют отображение осей и их названий соответственно. Каждый из них может принимать два значения - TRUE или FALSE:
```

```{r}
plot(indo.times, Mean1, xlab = "Время", ylab = "Концентрация",
       axes = TRUE, ann = FALSE)
plot(indo.times, Mean1, xlab = "Время", ylab = "Концентрация",
       axes = FALSE, ann = TRUE)
```

### 5. Параметр log

```{r}
#При помощи аргумента log можно перевести одну или обе оси графика на логарифмическую шкалу, например:
```

```{r}
plot(indo.times, Mean1, xlab = "Время", ylab = "Концентрация", log = "x")
plot(indo.times, Mean1, xlab = "Время", ylab = "Концентрация", log = "y")
plot(indo.times, Mean1, xlab = "Время", ylab = "Концентрация", log = "xy")
```

### 6. Параметр main

```{r}
#Аргумент main служит для создания названия графика. По умолчанию название
#размещается в верхней части рисунка:
```

```{r}
plot(indo.times, Mean1, xlab = "Время", ylab = "Концентрация",
       main = "Скорость выведения индометацина", type = "o")
```

```{r}
detach(Indometh)
```

# Примеры построения графика одной переменной с помощью функции plot

```{r}
## Построим график функции Sin на интервале (-3*pi, 3*pi), цвет -  красный,
#толщина линии -3, с заголовком, с подписями осей, с заголовком под графиком (аргумент sub)
```

```{r}
plot(sin, -3*pi, 3*pi, col = "red", lwd = "3", main = "График функции Sin(x)" , xlab = "x", ylab= "Sin(x)" , sub = "Интервал изменения аргумента = (-3*pi, 3*pi)") 
```

```{r}
 # Создадим свою функцию
f <- function(x){return(2*x^2-3*x+5)}

#Постройте график функции f на интервале (-5, 5)
plot(f,-5,5,)
```
### Задание1.

```{r}
#Выполните следующее:
#    1. Придумайте функцию одной переменной, отличную от линейной.
#    2. Постройте график функции на заданном интервале, с помощью параметров,
#использованных в рассмотренном выше примере, сделайте необходимые настройки.
```

```{r}
 # Создадим свою функцию
f <- function(x){return(sin(16*x)/sin(50*x))}
#Постройте график функции f на интервале (-5, 5)
plot(f,-5,5, col = "red", lwd = "2", main = "Придуманная функция")
```
# 2. Круговые диаграммы

```{r}
#Функция pie() имеет несколько аргументов. Основными из них являются:
#    • x - вектор из положительных чисел, на основе которых строится диаграмма;
#    • labels - текстовый вектор, содержащий подписи секторов диаграммы; если значения x уже имеют атрибут names (имена), то аргумент labels указывать не обязательно (см. ниже);
#    • radius - изменяет размер квадрата, внутри которого строится диаграмма; в случаях, когда подписи секторов диаграммы слишком длинные, размер этого квадрата можно уменьшить (возможные значения: от -1 до 1, см. ниже);
#    • init.angle - угол поворота диаграммы;
 #   • col - вектор (числовой или текстовый), содержащий коды цветов для заливки секторов диаграммы;
#    • main - текстовый вектор, содержащий заголовок диаграммы;
#    • ... - другие графические параметры (например, параметры, определяющие размер подписей секторов диаграммы, цвет линий, и т.п.).
```

```{r}
#В качестве примера рассмотрим результаты недавнего голосования в Госдуму Российской Федерации. Изобразим на одном рисунке две круговые диаграммы, отображающие явку избирателей и распределение их голосов. Для начала создадим два числовых вектора с данными:
```

```{r}
# Данные по явке избирателей:
percent.voted <- c(60, 40)

# Распределение голосов:
votes <- c(49.3, 19.2, 13.2, 11.7, 3.4, 1.0, 0.6)
```

```{r}
#Каждому элементу созданных векторов присвоим соответствующие имена при помощи функции names(). Эти имена потом будут автоматически использованы программой в качестве подписей секторов диаграммы:
```

```{r}
names(percent.voted) <-c ("Проголосовали", "Не явились")

names(votes) <- c("Единая Россия", "КПРФ", "Справедливая Россия", "ЛДПР", "Яблоко", "Патриоты России", "Правое дело")
```

```{r}
percent.voted
```

```{r}
votes
```
```{r}
#Поскольку стоит задача изобразить обе диаграммы на одном рисунке, графическое окно R необходимо разбить на две части. Для этого можно использовать команду par() и один из ее многочисленных аргументов - mfrow.
#Данная команда приведет к разбиению графического окна R на 2 ячейки, формирующие один столбец. Круговые диаграммы будут последовательно добавлены программой в каждую из этих ячеек:
```

```{r}
par(mfrow=c(2,1))
pie(percent.voted, radius = 1.0, cex = 0.6, main = "Явка")
pie(votes, cex = 0.6, radius = 1.0, init.angle = -10,
    main = "Распределение голосов")
```

```{r}
#Цвета заливки секторов диаграммы, используемые программой по умолчанию, можно изменить при помощи аргумента col. Например:
```

```{r}
pie(percent.voted, radius = 0.9, cex = 0.6, main = "Явка", 
   col = c("black", "gray80"))

pie(votes, cex = 0.6, radius = 0.9, init.angle = -10,
    main = "Распределение голосов",
    col = c(2:8))
```

# 3. Точечные диаграммы

```{r}
#Для начала загрузим соответствующую таблицу с данными (mtcars) в рабочую среду R и исследуем ее содержимое:

data(mtcars)
mtcars
```
```{r}
#В таблице имеются данные по 11 параметрам, характеризующим каждую модель. Подробнее о том, какие параметры были учтены, можно ознакомиться в файле помощи, доступном по команде mtcars. Для нас сейчас интересен столбец mpg, в котором содержатся данные по пробегу каждой модели в расчете на галлон топлива. Точечную диаграмму по этим данным можно быстро построить следующим образом:
```
```{r}
#В приведенном коде указаны следующие параметры функции dotchart():
#1) переменная, для которой строится график (mtcars$mpg); 2) текстовый вектор, содержащий #названия моделей автомобилей (в данном случае они являются названиями строк таблицы #-row.names(mtcars)); заголовок графика (аргумент main) и название оси X (аргумент xlab), и, #наконец, 4) размер точек на графике и одновременно размер шрифта для названий моделей (cex = #0.8). Результат представлен ниже:
```


```{r}
dotchart(mtcars$mpg, labels = row.names(mtcars),
   main="Экономия топлива у 32 моделей автомобилей",
   xlab="Миль/галлон", cex = 0.8)

```

```{r}
#Полученный рисунок пока еще достаточно сырой, хотя и позволяет исследовать разброс имеющихся значений mpg разных моделей. Картина станет гораздо более ясной, если мы отсортируем данные по возрастанию пробега, сгруппируем данные по количеству циллиндров в двигателе и раскрасим соответствующие группы разными цветами.
```

```{r}
#Сначала отсортируем исходную таблицу по возрастанию mpg (используем для этого функцию order()) и сохраним результат в виде новой таблицы данных с именем x):

x <- mtcars[order(mtcars$mpg), ]
```

```{r}
#Преобразуем количественную переменную cyl в новой таблице x в фактор - это нужно сделать, поскольку мы собираемся сгруппировать значения mpg именно по количеству цилиндров:

x$cyl <- factor(x$cyl)
```

```{r}
#Создадим новый столбец color в таблице x, который будет содержать числовые коды цветов для каждой из трех групп автомобилей:

x$color[x$cyl==4] <- 1
x$color[x$cyl==6] <- 2
x$color[x$cyl==8] <- 3
```

```{r}
#В приведенном коде аргумент groups используется для указания группирующей переменной (в нашем случае - преобразованная в фактор переменная cyl). При помощи аргумента gcolor задается цвет названий групп (здесь - голубой). Аргумент color служит для указания цветов, специфичных для каждой группы (в нашем примере - 1(черный) для машин с четырьмя цилиндрами, 2(красный) для машин с шестью цилиндрами, и 3 (зеленый) для машин с восемью двигателями; все эти числовые коды цветов хранятся в столбце color таблицы x).

dotchart(x$mpg, labels = row.names(x),		
       groups = x$cyl, gcolor = "blue", pch = 16, color = x$color,
       main="Экономичность двигателя у 32 моделей автомобилей",
       xlab="Миль/галлон", cex = 0.8)
```

# 4. Гистограммы

```{r}
X <- rnorm(n = 50, mean = 15, sd  = 5)
hist(X, breaks = 20, freq = FALSE, col = "lightblue")
```
```{r}
#Вместо гистограммы (или в добавок к ней) в таких случаях стоит воспользоваться кривой плотности вероятности. Оценка плотности вероятности выполняется при помощи функции density(), которую можно применить в качестве аргумента функции plot() для графического изображения результата:
```

```{r}
plot(density(X))
```

```{r}
#Гладкость получаемой кривой контролируется при помощи аргумента bw, например:

plot(density(X, bw = 0.8))
```

```{r}
#Обратите внимание на дополнительные аргументы, использованные вместе с функцией hist(): xlab и ylab - для создания названий осей, и main - для создания заголовка рисунка. Аналогично, в качестве управляющих аргументов функции lines() были применены аргументы col (для установки цвета линии) и lwd (для установки толщины линии). Эти же аргументы мы использовали ранее при построении графиков c помощью функции plot(). Приведенные примеры показывают универсальность этих и целого ряда других аргументов, управляющих поведением plot(), hist() и других графических функций R высокого уровня.
```

```{r}
hist(X, breaks = 20, freq = FALSE, col = "lightblue",
      xlab = "Переменная X",
      ylab = "Плотность вероятности",
      main = "Гистограмма, совмещенная кривой плотности")
lines(density(X), col = "red", lwd = 2)
```
# 5. Диаграммы размахов
```{r}
#Диаграммы размахов, или "ящики с усами", получили свое название за характерный вид: точку или линию, соответствующую медиане или средней арифметической, окружает прямоугольник ("ящик"), длина которого соответствует одному из показателей разброса или точности оценки генерального параметра. Дополнительно от этого прямоугольника отходят "усы", также соответствующие по длине одному из показателей разброса или точности. Графики этого типа очень популярны, поскольку позволяют дать очень полную статистическую характеристику анализируемой совокупности. Кроме того, диаграммы размаха можно использовать для визуальной экспресс-оценки разницы между двумя и более группами (например, между датами отбора проб, экспериментальными группами, участками пространства, и т.п.).
```

```{r}
#В R для построения диаграмм размахов служит функция boxplot()
```

```{r}
#в отличие от других статистических программ, в R при построении диаграмм размахов используются устойчивые (робастные) оценки центральной тенденции (медиана) и разброса (интерквартильный размах, ИКР). Верхний "ус" простирается от верхней границы "ящика" до наибольшего выборочного значения, находящегося в пределах расстояния 1.5 х ИКР от этой границы. Аналогично, нижний "ус" простирается от нижней границы "ящика" до наименьшего выборочного значения, находящегося в пределах расстояния 1.5 х ИКР от этой границы. Длину данного интервала (т.е. 1.5 x ИКР) можно изменить при помощи аргумента range функцииboxplot(). Наблюдения, находящиеся за пределами "усов", потенциально могут быть выбросами. Однако всегда следует внимательно относиться к такого рода нестандартным наблюдениям - они вполне могут оказаться "нормальными" для исследуемой совокупности, и поэтому не должны удаляться из анализа без дополнительного расследования причин их появления.
```

```{r}
#Особенности использования функции boxplot() рассмотрим на примере данных, полученных в ходе эксперимента по изучению эффективности шести видов инсектицидных средств. Каждым из этих средств обработали по 12 растений, после чего подсчитали количество выживших на растениях насекомых. Данные этого эксперимента входят в состав стандартного набора данных R и доступны по команде data(InsectSprays). В таблице InsectSprays имеется два столбца - count, содержащий результаты подсчета насекомых, и spray, содержащий коды инсектицидных средств (от А до F):
```


```{r}
data(InsectSprays)
```

```{r}
InsectSprays
```

```{r}
#Для построения графика, на котором будут представлены "ящики с усами" для каждого инсектицида, достаточно выполнить команду

boxplot(count ~ spray, data = InsectSprays)
```
```{r}
#Обратите внимание на то, как были указаны переменные для построения графика - в виде т.н. формулы: count ~ spray. Это стандартный способ, используемый в R для формулировки статистических моделей. По левую сторону от знака ~ (называется "тильда") указывается зависимая переменная, по правую - предикторы. Как видим, количество насекомых на растениях, обработанных инсектицидами C, D и E было наиболее низким, что говорит о высокой эффективности этих средств по сравнению с тремя другими средствами. На растениях, обработанных средствами C и D, были отмечены необычно высокие количества насекомых (см. точки над "усами"). Однако для насекомых характерно пятнистое пространственное распределение и поэтому вряд ли эти необычно высокие наблюдения являются истинными выбросами.
```

```{r}
#Как всегда, мы можем поработать над автоматически построенным графиком и несколько улучшить его внешний вид. Например, можно добавить заголовки осей и самого рисунка (аргументы xlab, ylab и main), а также закрасить "ящики" каким-нибудь цветом (аргумент col):
```


```{r}
boxplot(count ~ spray,
            xlab = "Инсектициды",
            ylab = "Количество выживших насекомых",
            main = "Эффективность инсектицидов",
            col = "coral", data = InsectSprays)
```
```{r}
#Подобно функции plot(), функция boxplot() обладает большим числом управляющих аргументов. Например, используя аргумент log можно изобразить данные на логарифмической шкале. Аргумент varwidth (от variable - переменная, и width - ширина) позволяет сделать так, что ширина "ящиков" будет пропорциональна квадратному корню из числа наблюдений в каждой группе (для этого необходимо использовать varwidth = TRUE). Это может оказаться полезной оцпией для визуализации выборок, значительно различающихся по размеру (в нашем примере смысла в varwidth = TRUE не было бы, поскольку в каждой группе имеется по 12 наблюдений). Аргумент horizontal со значением TRUE позволяет изобразить "ящики" горизонтально (см. ниже). Подробнее об аргументахboxplot() можно узнать из файла помощи по этой функции (доступен по команде boxplot).
```

```{r}
boxplot(count ~ spray,
            ylab = "Инсектициды",
            xlab = "Количество выживших насекомых",
            main = "Эффективность инсектицидов",
            col = "coral", horizontal = TRUE,
            data = InsectSprays)
```
```{r}
#Интересно, что построить диаграммы размаха можно не только при помощи специализированной функции boxplot(), но также и функции plot() - например, по команде plot(count ~ spray, data = InsectSprays). Дело в том, что функция plot() очень "смышленая" - она автоматически распознает, что переменная count является количественной, а spray - номинальной, и поэтому начинает вести себя как boxplot().
```

```{r}
plot(count ~ spray, data = InsectSprays, col = "green")
```

# 6. Столбиковые диаграммы

```{r}
#Для создания столбиковых диаграмм в системе R служит функция barplot(). У этой функции имеется большое количество аргументов:
#    • hight ("высота") - числовой вектор или матрица со значениями, используемыми для построения диаграммы. Если аргумент hight указан в виде вектора, то строится график из последовательно расположенных столбцов, высоты которых соответствовуют значениям этого вектора. Если hight указан в виде матрицы и аргумент beside = FALSE, то будет построена столбчая диаграмма с накоплением. Если жеhight указан в виде матрицы и аргумент beside = TRUE, то столбцы диаграммы будутсгруппированы в соответствии со столбцами матрицы.
#    • width("ширина") - необязательный параметр, позволяющий регулировать ширину столбцов на диаграмме. Указывается в виде числового вектора, значения которого соотвествуют ширине столбцов.
#    • space("пространство") - величина зазора между столбцами (пропорционально их средней ширине). Может быть указан либо виде одного числа, либо в виде вектора из чисел, соотвествующих каждому столбцу диаграммы.
#    • names.arg- текстовый вектор, содержащий подписи (вдоль оси OX) для каждого столбца или группы столбцов. Если этот аргумент не указан, в качестве подписей автоматически будут использованы имена элементов вектора height(если таковые имеются), либо заголовки столбцов если height представляет собой матрицу.
#    • legend.text - вектор, содержащий текстовые элементы легенды графика. Этот аргумент полезен только если height является матрицей. В этом случае метки легенды должны соотвествовать строкам матрицы. Аргументу legend.text можно также присвоить значение TRUE, и тогда имена строк матрицы (если таковые имеются) будут использованы в качестве меток легенды автоматически.
#    • beside - принимает логическое значение и имеет смысл только, если height является матрицей. Значение FALSE приведет к построению диаграммы с накоплением. При значении TRUE столбцы будут сгруппированы.
#    • horiz - принимает логическое значение: TRUE для горизонтального расположения столбцов и FALSE - для вертикального.
#    • density - числовой вектор, задающий плотность заштриховки столбцов.
#    • angle - угол наклона штрихов (в градусах).
#   • col - вектор цветовых кодов для столбцов или их элементов. По умолчанию столбцы закрашиваются серым цветом если height - вектор, и разными градациями серого если height - матрица.
#    • border - код цвета для обводки столбцов. Если границу столбцов обводить не предполагается, можно указать border = NA.
#    • ...- другие графические параметры (см., например, ?plot и ?par).
```

```{r}
#В качестве первого примера используем данные по эффективности шести инсектицидных средств
#(A - F), входящие в базовую комплектацию R. Загрузим таблицу с этими данными в рабочую среду R:
```

```{r}
data(InsectSprays)
 InsectSprays 
```
```{r}
#Стоит задача отобразить в виде столбиковой диаграммы средние значения количества насекомых, учтенных на экспериментальных растениях после обработки каждым инсектицидом. Эти средние значения можно быстро рассчитать для каждой группы при помощи функции tapply(). Результат вычислений сохраним в векторе Means: 
```

```{r}
attach(InsectSprays)
```

```{r}
Means <- tapply(count, spray, mean); Means
```

```{r}
barplot(Means, col = "steelblue", xlab = "Инсектицид", ylab = "Количество выживших насекомых") 
```

```{r}
#Изменим ширину столбцов (теперь она пропорциональна квадратному корню из высоты соответствующего столбца - аргумент width) и цвет их обводки (на красный - аргумент border):
```

```{r}
barplot(Means, col = "steelblue", xlab = "Инсектицид", ylab = "Количество выживших насекомых", border = "red", width = sqrt(Means))
```
```{r}
#Столбцы имеют исходную ширину и цвет обводки, но теперь они заштрихованы (аргумент density) и изображены горизонтально (аргумент horiz):
```

```{r}
barplot(Means, density = 20, col = "red", horiz = T, las = 1, ylab = "Инсектицид", xlab = "Количество выживших инсекомых") # аргумент las=1 заставляет названия инсектицидов принять вертикальное положение
```
```{r}
#Изменим предыдущий график путем увеличения зазора между столбцами (аргумент space) и измения угла наклона штрихов (аргумент angle):
```
 
```{r}
barplot(Means, density = 20, angle = -45, space = 2, col = "red", horiz = TRUE, las = 1, ylab = "Инсектицид", xlab = "Количество выживших инсекомых")
```
```{r}
#Рассмотрим пример построения диаграммы, где столбцы сгруппированы в соответствии с уровнями какого-либо фактора: таблица genotype, входящая в состав пакета MASS. В эту таблицу входят данные из эксперимента, в котором были задействованы лабораторные крысы четырех разных генотипов (A, B, C, D). Выводок (Litter) от самок (Mother) каждого генотипа изолировался от матерей и отдавался на вскармливание самкам других генотипов. В конце эксперимента (на 28-й день) был измерен вес у крысят (Wt), кормившихся молоком от разных самок, с целью установить влияние генотипа на этот показатель.
#Ознакомимся с данными:
```

```{r}
library(MASS)
data(genotype)
genotype
```
```{r}
#Рассчитаем средние значения веса для каждой экспериментальной группы при помощи функции tapply():
```

```{r}
means = with(genotype, tapply(Wt, list(Litter, Mother), mean))

# Функция with() позволяет указать таблицу, из которой
# функция tapply() должна брать данные для вычислений

# Просмотрим содержимое матрицы means:
means
```
```{r}
#Результатом вычислений, выполненных при помощи функции tapply(), является матрица, которую мы можем непосредственно использовать для построения столбчатой диаграммы:
```

```{r}
barplot(means, beside = TRUE,
       col = topo.colors(4),
       legend.text = rownames(means),
       xlab = "Выводок", ylab = "Вес, г",
       ylim = c(0, 100))
```
```{r}
#В приведенном коде цвет столбцов задан при помощи функции topo.colors(), которая автоматически подбирает необходимое количество хорошо сочетающихся цветов в стиле "топографическая карта". Легенда графика включена при помощи агрумента legend.text, которому присвоены значения в виде заголовков строк матрицы means. Для того чтобы легенда не "наползла" на столбцы, несколько растянули ось OY при помощи аргумента ylim. Обратите внимание на то, что для построения приведенного графика аргументу beside было присвоено значение TRUE. Если бы мы присвоили этому аргументу значение FALSE, то получили бы столбиковую диаграмму с накоплением:
```

```{r}
barplot(means, beside = FALSE,col = topo.colors(4),
         xlab = "Выводок", ylab = "Вес, г")
```
```{r}
#К столбцам диаграмм мы можем добавить "усы", соответствующие, например, стандартным отклонениям. Стандартные отклонения легко рассчитать, используя все ту же функцию tapply() (в связке с with()):
```

```{r}
sds = with(genotype, tapply(Wt, list(Litter, Mother), sd))

# Просмотрим результат:
sds
```
```{r}
#Подобно ранее рассмотренному примеру, "усы" к столбцам можно добавить при помощи функции arrows():

# Сохраним диаграмму в виде самостоятельного объекта b.
# Помимо прочего, этот объект будет хранить информацию
# о высоте столбцов, что потребуется далее при добавлении
# "усов" к этим столбцам.
# Аргумент ylim в связке с функциями min(), max() и pretty()
# используется для автоматического подбора оптимального
# диапазона значений, отображаемых на оси ординат (подробнее
# см. ?min, ?max?, ?pretty):
```

```{r}
b <- barplot(means, ylim = c(min(pretty(means-sds)),
             max(pretty(means+sds))),
             col = topo.colors(4),
             beside = TRUE, xpd = FALSE,
             ylab = "Вес, г", xlab = "Выводок",
             legend.text=rownames(means))

arrows(b, means+sds, b, means-sds, angle = 90, code = 3, length = 0.05)
```























